

## 클래스의 구성


프로그램을 출력하는 프로그램의 재료라고 할 수 있으며 크게 필드, 생성자, 메소드 정도로 나누어 생각할 수 있습니다.

특이한 것은 메인 메소드는 항상 위에서 아래로 흐름이 흘러가지만 일반적인 클래스는 이 필드, 생성자, 메소드의 위치가 아무렇게 위치하여도 정상적으로 사용할 수 있습니다.

다만 사용자의 입장에서 이 클래스를 참조하는 과정에서 난잡하고 알아보기 어려울 수 있기 때문에 보통 필드 > 생성자 > 메소드 를 작성하는 것이 기본입니다.





#### 생성자
#생성자


public Rectangle() {
}
위 의 작성 내용을 생성자라고 하며 가장 기본적인 형태입니다.
public 뒤에 바로 클래스의 이름을 작성하고 괄호안에는 이전에 작성 해 놓은 필드에 대입할 숫자, 문자, 문자열 등등을 메소드 작성 때와 동일하게 사용할 수 있습니다.

다만 메소드와 생성자가 같은 이름과 파라미터를 가지고 있다고 하더라도 둘은 서로 사용하는 원리와 목적이 다르기 때문에 컴파일 오류를 발생시키지 않습니다.

마지막으로 생성자는 구성요소가 다르다면 당연히 여러 종류의 생성자를 작성 할 수 있습니다.


그러면 생성자를 이용하는 예제를 간단하게 살펴봅시다.



ex1 : Human의 이름을 가지는 클래스 안의 내용

```
public class Human {
	String name;
	int age;

	public Human(String n, int a) {
		name = n;                     // <<<이것이 생성자
		age = a;
	}

}
```

ex2 : HumanTest의 이름을 가지는 메인 메소드 안의 내용

```
Human h1 = new Human("길동", 22);
Human h2 = new Human("둘리", 33);
```

기존에는 새로운 Human클래스를 참조하는 인스턴트를 생성하고, 다시 생성한 사람의 정보를 우리가 기입해주었습니다.

하지만 이번 예제는 new Human 뒤의 ()안에 자신이 초기화 시킬 숫자나 문자열 등의 정보를 기입 하여 놓으면 생성한 사람들의 필드값을 바로 적용 시키고 사용할 수 있습니다.


* ex1 의 생성자는 문자열 형식의 n, 정수 형식의 a 를 받으면 미리 필드에 만들어 놓은 name에 n을, age에 a를 대입하라는 내용입니다.


다만 생성자를 직접 작성한 경우 기존처럼 파라미터 값을 () 빈 괄호로 작성할 시 오류가 발생합니다.

이 이유에 대해서는 기존의 방식은 우리가 생성자를 따로 입력하지 않았었고 컴퓨터는 사용자가 생성자를 작성하지 않았다면 자동으로 가장 기초적인 생성자인
public Rectangle() {} 를 만들어 놓았기 때문입니다.

public Rectangle() {} 의 생성자는 딱히 내용도 없고 받아오는 파라미터의 값도 없기 때문에 우리가 인스턴트를 생성할 때 빈 괄호로 사용할 수 있었습니다.


하지만 사용자가 직접 사용자를 작성하게 되면 컴퓨터는 이 기초 생성자를 작성하지 않기 때문에 빈 괄호의 인스턴트 생성을 할 수 없게 됩니다.
 


#### 생성자 사용해보기


```
public Cup(int v, boolean h) {
volume = v;			//1번
handle = h;
}
	
public Cup(int y) {
volume = y;			//2번
handle = false;
}


메인메소드에서 실행시
Cup c3 = new Cup(300);		    //2번 생성자를 이용하여 초기화
Cup c4 = new Cup(400, false);	//1번 생성자를 이용하여 초기화
```


생성자는 공통된 이름과 파라미터를 작성하지 않는다면 여러개를 만들 수도 있습니다.
그리하여 위 예제에서 컵의 용량과 손잡이 여부를 모두 파라미터에 작성하면 1번의 생성자를 이용하여 초기화 과정을 거치게 되고,
컵의 용량만 입력하면 2번 생성자를 이용하여 초기화 과정을 거칩니다.

2번의 경우 손잡이 여부는 false로 되어있기 때문에 새로 만드는 컵이 손잡이가 없다면 사용자는 용량만 파라미터에 입력하였어도 자동으로 용량 및 손잡이의 유무를 false로 초기화 하여 정보를 사용할 수 있습니다.

이는 사용하기에 따라 코드를 작성하는 시간도 단축 시키고 편리성을 증대 시켜줄 수 있습니다.

* 참고사항
필드를 선언만 하고 초기화 없이 사용 할 때 기본  값
정수형 : 0
실수형 : 0.0
논리형 : false
참조형(Scanner, String 등등) : Null

참조형은 참조할 것이 없는 상황에서 인스턴트 생성을 하게 되면 Null 출력합니다.

하지만 Null 값은 실체 객체를 가르키는 것이 아니기 때문에 사용하려고 하면 실행 중 오류가 발생합니다.


---
예시 :
c1.name.length(); 

(c1의 이름을 초기화 하지 않았으니 Null로 대체될 것이고 실체가 없는 값이기에 글자수의 길이를 알 수 없음.)

---






### this 사용해보기
#this

만약 name 이라는 상태를 필드 값으로 두고, 생성자에서 받아오는 파라미터의 이름도 name이라고 가정합시다.


이러면 컴퓨터 입장에서는 이 후 name을 적을 때 어떤 값을 가져와야 하는지 알 수 없습니다.

따라서 이런 경우에는 name이 작성된 문장들 중 가장 가까운 곳에서 작성된 타입과 값을 가져옵니다.



```
public class Student2 {
	String name;
	public Student2(String name) {
	name = name;
	}
}
```

위의 코드에서 필드에 작성한 name에 상대방이 파라미터에 입력한 name이라는 문자열을 대입하고 싶어했지만 
컴퓨터는 후자의 name = 후자의 name 이라고 인식하여 제대로 동작하지 않습니다.

이름을 동일하게 사용하면서 전자의 name을 인식 시킬 수 있다면 정상적으로 동작 할 것이고 이 방법이 this. 을 앞에 붙여주는 것 입니다.

this.name = name;

위와 같이 입력하면 전자의 this.name은 필드에 있는 name이라고 인식하게 됩니다.
(상태들은 모두 this.을 가지고 있지만 생략하고 있으며, 컴퓨터가 헷갈려하는 상태 이름들만 붙여준다고 생각하면 쉽습니다.)


또한 this의 다른 사용 방법으로 
자신이 가지는 생성자를 불러올 때 this()를 사용하며,
괄호 안에 본인이 사용하려는 생성자의 파라미터 조건을 따라 작성하면 됩니다.
특이사항은 이 this()는 언제나 첫 문단에 위치하여야만 컴파일 오류가 발생하지 않습니다.



### getter 와 setter란
#getter 
#setter


get은 "접근자"이며 getter라고 부릅니다.
set은 "설정자"이며 setter라고 합니다.


get의 기본 형식은

```
public String getMenu() {
		return menu;
}
```

set의 기본 형식은

```
public void setMenu(String menu) {
		this.menu = menu;
}
```



위의 작성 내용을 보면 내용을 대강 유추할 수 있는데 위 내용을 기준으로
get을 사용하는 경우에는 menu의 값을 가지고 돌아오게 될 것이고,
set을 사용하는 경우에는 menu의 값을 사용자가 수정할 수 있습니다.

여기서 get은 단순히 값을 가지고 오는 것이기에 별다른 문제가 없을 가능성이 크지만
set은 사용자가 수정할 수 있는 부분이고 사용자가 잘못 수정하는 경우도 있을 수 있습니다.

따라서 set을 작성할 때 초기 작성자가 원하는 값만 받아 변경하고 싶다면 
자신이 원하는 기준을 if else 구문으로 구성하여 추가 조건을 작성할 수 있습니다.

문제 삼을만한 부분은 필드의 종류가 많아질수록 필연적으로 getter와 setter를 많이 작성해야 하는데
다행스럽게도 이클립스는 이 부분에 대해서 오토로 작성할 수 있습니다.




---

클래스의 필드만 작성 해놓고 생성자를 오토로 만드는 경우.

화면에 마우스 우클릭 > source > Generate Constructor using Fields > 초기화가 필요한 필드들을 체크 후 확인.



getter와 setter를 오토로 만드는 경우.

화면에 마우스 우클릭 > source > Generate Getter and Setter > getter와 setter를 필요로 하는 필드들을 모두 체크 후 확인.

---













## 0613 내용의 키워드 간단 정리

#### 1. 인스턴스 생성시, 필드 초기화를 위해 호출하는 것?

생성자라고 부르며 작성하지 않을 시 기본 생성자를, 작성하였다면 작성내용의 조건에 따라 맞추어 인스턴트를 생성하여야 한다.

#### 2. 생성자의 네이밍 규칙?

생성자의 이름은 클래스의 이름과 동일하게 작성해야 한다.
#### 3. 기본 생성자란?

사용자가 생성자를 작성하지 않고 메인 메소드에서 인스턴트 생성을 할 때 컴퓨터가 알아서 만드는 생성자의 가장 기본적인 형태.
#### 4. 기본형 타입, 참조형 타입의 기본값은?

정수의 기본형 = 0
실수의 기본형 = 0.0
논리형의 기본형 = false
참조형의 기본형 = null 
#### 5. 기본 생성자가 컴파일러에 의해 자동 생성되지 않는 경우는?

클래스 내부에 사람이 직접 생성자를 작성하면 기본 생성자는 생성되지 않는다.
#### 6. 파라미터를 달리하는 생성자를 여러 개 정의할 때, 컴파일러가 중복으로 판별하는 규칙은?

파라미터의 순서, 형식, 갯수 등등이 모두 일치하는 경우 중복이라고 판별.
#### 7. this?

컴퓨터가 필드를 잘못인식할 때 this. 를 사용하여 필드값인 것을 명시.

자신의 생성자를 가져와 사용하는 경우 this()를 사용. 
괄호 안에 가져올 생성자의 파라미터 조건을 따라 작성.
#### 8. 생성자 내부에서 자신의 생성자를 호출할 때, 주의해야 할 점?
this(qwer); 를 사용하여 생성자를 호출할 때 반드시 이 작성문은 가장 위에 위치해야 한다.
그렇지 않으면 컴파일 오류를 발생시킨다.
#### 9. 접근자 getter, 설정자 setter는 무엇인가요?

클래스의 특정 상태값을 가져오고자 할 때 get을
클래스의 특성 상태값을 변경하고자 할 때 set을 사용

set은 의도와 달리 변경되는 것을 막기 위하여 특정 조건을 넣어서 작성할 수 있음.
