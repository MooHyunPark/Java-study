


# 상속
#상속

is - a 관계라고 하며 부모 클래스와 자식 클래스로 구성되어 있습니다.


기존에 클래스를 작성하던 방법에서
public class "자식 클래스 이름" extends "부모 클래스 이름" 과 같은 형식으로 작성할 수 있으며
항상 extends 앞에는 자식 클래스를, 뒤에는 부모 클래스를 작성하여야 합니다.

자식 클래스는 부모 클래스로부터 필드들과 메소드 기능 등등을 상속 받을 수 있으며 이 때문에 자식 클래스에서 특정 필드를 선언하지 않더라도 해당 필드가 부모 클래스에 있다면 자연스럽게 해당 필드를 포함하게 됩니다.

* 부모 클래스는 1개의 클래스만 상속 받을 수 있습니다.


```
public class Cat extends Animal {

	
	public Cat(String name, int age) {
		super(name, age);
	}

	public void meow() {
		System.out.println("야옹");
	}
}
```

위의 코드에서 Cat이라는 클래스는 이름과 나이라는 필드가 없는 상태이지만 Animal클래스를 부모클래스로 두고 있어 이름과 나이라는 필드를 초기화 및 사용할 수 있습니다.
다만 기존의 (this.필드명)를 이용하여 초기화하던 방법과는 달리 부모클래스에 해당하는 사항들은 모두 super를 이용하여 초기화 하여야 합니다.
그리고 super는 해당 메소드 위치에서 가장 위에 위치하고 있어야 합니다.





## Override
#override


부모 클래스가 가지고 있는 메소드의 작성 양식을 그대로 자식 클래스에서 따라 작성할 경우, 새로 작성한 내용을 호출하게 되고 이렇게 메소드를 재정의 하는 것을 Override라고 합니다.
다만 오버라이드를 할 때 조금이라도 메소드 헤더가 다르다면 재정의가 아닌 새로 정의한 것이기 때문에 유의해야 합니다.
만약 재정의를 하려고 할 때 실수를 방지하고 싶다면 @Override 를 메소드 위에 작성하면 좋습니다.

어노테이션(Annotation)이라고 하며 어노테이션은 개발자가 오버라이드의 의도가 있을 때, 서로 헤더가 동일한지 컴파일 단계에서 확인을 하고, 만약 다르다면 컴파일 오류를 통하여 사용자에게 알려줄 수 있습니다.

그리고 기존에 자주 해보았던 이름은 같으나 파라미터 타입을 다르게 생성하는 경우는 Overload라고 합니다.




### UpCasting, DownCasting

서로 간에 상속 관계에서, 자식 클래스에서 부모 클래스의 형으로 변환하는 것을 업 캐스팅 , 반대는 다운 캐스팅이라고 하며
다운 캐스팅은 괄호를 사용하여 따로 명시를 시켜주어야만 정상적으로 작동합니다.

다만 다운 캐스팅을 하는 경우 문법적 오류는 없어도 실행 중 오류가 발생하는 경우가 있습니다.


예를 들어

강아지 클래스
고양이 클래스
각 클래스는 동물이라는 클래스를 부모 클래스로 가지고 있음.

강아지 객체를 생성하여 동물이라는 부모 클래스의 형태로 변환 가능.
사용도 가능하며 고양이도 동일.

하지만 강아지 객체를 부모 클래스로 업 캐스팅 한 후 고양이 클래스로 다운 캐스팅을 하게 되면 애초에 강아지를 만들었고 고양이가 될 수 없으니 실행 중 오류가 발생합니다.


Animal animal1 = new Dog("원래부터 강아지였음", 4);
Animal animal2 = new Cat("원래부터 고양이였음", 3);
		
Dog dog1 = (Dog)animal1;  //강아지로 다운 캐스팅 가능
Dog dog2 = (Dog)animal2;  //강아지로 다운 캐스팅 불가능




이렇게 형이 서로 다 다를 수 있고 이를 형을 비교할 때는  instanceof를 사용하면 되며 비교할 객체 instanceof 비교할 대상의 형태  와 같은 형식으로 작성할 수 있습니다.
결과값은 true 와 false로 나타납니다.

ex

man1 instanceof Customer
= man1이라는 객체의 형태는 Customer인가?



위의 경우들과 같이 객체는 다양한 형을 가질 수 있고 이를 다형성이라고 합니다.


# 추가 정보
* 클래스를 만들 때 class 앞에 final을 붙여주게 되면 해당 클래스는 상속을 허용하지 않습니다.

### 추가 접근 제한자
#접근제한자

protected 는 default 패키지 기능에 더하여 패키지가 달라도 자식 클래스에 한에서는 접근이 가능하게 하는 것을 protected 접근 제한자라고 합니다.

public :
*  모든 클래스에서 접근할 수 있습니다.
-  다른 패키지에서도 접근이 가능합니다.

protected : 
-  같은 패키지 내의 클래스와 상속 받은 클래스에서 접근할 수 있습니다.
-  다른 패키지에 있는 클래스라도 상속받은 경우 접근이 가능합니다.

default : 같은 위치에 위치한 클래스들만 사용 가능
-  접근 제한자를 명시하지 않은 경우 적용됩니다.
-  같은 패키지 내의 클래스에서만 접근할 수 있습니다.
-  다른 패키지에서는 접근이 불가능합니다.

private : 
* 클래스 외부에서는 사용 불가능 합니다.











### 오늘의 키워드 정리


1. 상속이란?
   부모 클래스와 자식 클래스로 이루어져 있으며 자식 클래스는 부모 클래스의 특징들을 모두 받아옵니다.
   
 2. 기존의 클래스에서 상속으로 파생된 클래스를 무엇이라고 부르나?
	 자식 클래스.
 
 3. Super 클래스에서 private 멤버는 자식 클래스에서 접근이 가능한가?
	 접근이 불가능.
	 
 4. Java에서 다중 상속 (부모 클래스가 여럿)은 가능한가?
	 불가능.
	 
 5. 메소드 재정의(Override) 하고자 할 때, Super 클래스의 인스턴스 메소드와 동일하게 적어야 하는 것?
	 메소드 헤더 모두.
	 
 6. 메소드 재정의 의도를 컴파일러에게 알리는 방법?
	@Override를 메소드 위에 작성.
	
 7. 중단(final) 클래스?
	 class 앞에 final을 붙이면 상속이 불가능 해짐.
	 
 8. 부모 클래스의 생성자를 명시적으로 호출하지 않는 경우, 어떠한 생성자가 호출되는가?
	기본 생성자를 호출