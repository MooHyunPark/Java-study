


class 내부에 정의된 클래스를 InnerClass라고 합니다.

innerClass 를 사용하기 위해서 다음과 같은 예시를 작성하였습니다.

```
class OuterClass {
	class InnerClass{}
	
	public void doSomthing() {
		new InnerClass();
	}
}

```

이후 메인메소드에서
OuterClass outerClass = new OuterClass();
OuterClass.InnerClass innerClass = outerClass.new InnerClass();


라고 작성하면 InnerClass를 사용할 수 는 있으나
복잡하기 때문에 실질적으로는 거의 이런식으로 사용하지 않으며
외부에서 접근을 하지 못하게 만드는 경우가 많습니다.





# Singleton 



싱글턴은 단 하나의 인스턴스만 존재하도록 보장하는 패턴을 의미합니다.

### 싱글턴 패턴 구현

1. **단일 인스턴스 유지**: 클래스 내에 단 하나의 인스턴스를 유지할 정적 필드를 선언합니다.
2. **생성자 접근 제한**: 생성자를 `private`으로 선언하여 외부에서 인스턴스를 직접 생성하지 못하게 합니다.
3. **전역 접근 메소드 제공**: 인스턴스를 반환하는 정적 메소드를 작성합니다. 이 메소드는 인스턴스를 기존의 인스턴스를 반환합니다.

반환 받은 인스턴스로 클래스를 생성 할 수 있으며, 해당 클래스의 기능을 이용할 수 있습니다.

따라서 사용자는 생성자에도 접근할 수 없고 필드도 일반적인 방법이 아닌 getter로만 접근 가능 하기에 임의적인 수정이 불가합니다.



##### 장점

전역 접근:
싱글턴 인스턴스는 어디서든 접근할 수 있으므로 전역 상태를 유지하거나 공유해야 하는 경우에 적합합니다.

인스턴스 관리의 용이성:
클래스 인스턴스를 하나만 유지하므로 메모리 낭비를 줄일 수 있습니다.

상태 유지:
하나의 인스턴스만 존재하기 때문에 해당 인스턴스의 상태를 쉽게 유지하고 관리할 수 있습니다.

리소스 절약:
예를 들어, 데이터베이스 연결과 같은 리소스를 공유할 때 유용합니다. 여러 개의 연결을 생성하는 대신 하나의 연결을 재사용할 수 있습니다.



##### 단점

테스트의 어려움:
싱글턴 패턴은 전역 상태를 가지므로 단위 테스트에서 독립적이고 예측 가능한 테스트 환경을 만들기 어렵습니다. 특히 테스트 간에 상태가 공유될 경우 테스트가 상호 의존적일 수 있습니다.

유연성 저하:
클래스의 인스턴스를 하나만 생성하도록 강제하므로 다형성을 활용하기 어려워지며, 나중에 설계를 변경하기 어렵습니다.

의존성 증가:
코드가 싱글턴 인스턴스에 의존하게 되므로 결합도가 높아질 수 있습니다. 이는 코드의 유지 보수성과 확장성을 저해할 수 있습니다.

멀티스레드 환경 문제:
멀티스레드 환경에서 동기화 문제를 올바르게 처리하지 않으면 인스턴스가 여러 개 생성될 수 있는 위험이 있습니다. 이를 해결하기 위해 동기화를 추가하면 성능 저하가 발생할 수 있습니다.



요약
싱글턴 패턴은 전역 상태를 관리하고 특정 자원을 공유해야 하는 상황에서 유용하지만, 단위 테스트의 어려움, 유연성 저하, 높은 결합도, 멀티스레드 환경에서의 문제 등 다양한 단점을 가지고 있습니다. 이러한 장단점을 고려하여 싱글턴 패턴을 적절히 활용하는 것이 중요합니다.




